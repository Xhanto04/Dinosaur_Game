# -*- coding: utf-8 -*-
"""22301108_CSE-423_Project_Group-9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pbJDsxg5MCTA6KQb06L6syo4XQ_X0EKl
"""

from OpenGL.GL import *
from OpenGL.GLUT import *
import random
import math

# Window dimensions
WIDTH, HEIGHT = 800, 400

# Dinosaur settings
dino_xx = 100
base_y = 50
norm_jump_height = 114
boost_jump_height = 180
current_y = base_y
jumping_speed = 2.5
jumping = False
falling = False
boost_jump = False
jump_height = norm_jump_height
bonus_jump = False  # Bonus jump score flag

# Tree settings
tree_below_width = 20  # Square trunk width
new_trunk_height = 20  # Square trunk height
tree_leaf_radius = 15  # Smaller circle for tree head
tree_speed = 2
trees = []
tree_spawn_timer = 0

# Food settings
food_radius = 10
food_speed = 2
food = None
food_spawn_score = 5
food_timer = 0

# Rainfall settings
raindrops = []  # List to store raindrop positions
rain_spawn_rate = 5  # Number of frames between new raindrop spawns
rain_speed = 4  # Speed at which raindrops fall
max_raindrops = 200  # Maximum number of raindrops at a time

# Game state
game_over = False
score = 0
fight_mode = False
used_chance = False
extra_life = False
extra_life_used = False
dino_health = 100
enemy_health = 100
projectiles = []
enemy_projectiles = []
projectile_speed = 5
enemy_jumping = False
enemy_falling = False
enemy_current_y = base_y
enemy_jumping_speed = 5

# Theme state (Day/Night)
day_theme = False


def mp_circle(x_center, y_center, radius):
    glBegin(GL_POINTS)
    x = radius
    y = 0
    p = 1 - radius
    while x >= y:
        glVertex2f(x_center + x, y_center + y)
        glVertex2f(x_center - x, y_center + y)
        glVertex2f(x_center + x, y_center - y)
        glVertex2f(x_center - x, y_center - y)
        glVertex2f(x_center + y, y_center + x)
        glVertex2f(x_center - y, y_center + x)
        glVertex2f(x_center + y, y_center - x)
        glVertex2f(x_center - y, y_center - x)
        y += 1
        if p <= 0:
            p += 2 * y + 1
        else:
            x -= 1
            p += 2 * (y - x) + 1
    glEnd()


def mp_line(x0, y0, x1, y1):
    glBegin(GL_POINTS)
    dx = x1 - x0
    dy = y1 - y0
    d = 2 * dy - dx
    incrE = 2 * dy
    incrNE = 2 * (dy - dx)
    x, y = x0, y0
    glVertex2f(x, y)
    while x < x1:
        if d <= 0:
            d += incrE
            x += 1
        else:
            d += incrNE
            x += 1
            y += 1
        glVertex2f(x, y)
    glEnd()


def draw_dino(x, y):
    glColor3f(0.0, 1.0, 0.0)  # Green color for the entire dinosaur

    # Body
    glColor3f(0.0, 1.0, 0.0)
    mp_circle(x, y + 15, 10)  # Body outline (reduced radius)
    for radius in range(0, 10):
        mp_circle(x, y + 15, radius)  # Filled body

    # Head
    glColor3f(0.0, 1.0, 0.0)
    mp_circle(x + 10, y + 30, 5)  # Head outline (moved slightly upward and right, reduced radius)
    for radius in range(0, 5):
        mp_circle(x + 10, y + 30, radius)  # Filled head

    # Neck
    glColor3f(0.0, 0.8, 0.0)  # Slightly darker green for less prominence
    mp_circle(x + 6, y + 22, 3)  # Neck outline (reduced radius)
    for radius in range(0, 3):
        mp_circle(x + 6, y + 22, radius)  # Filled neck

    # Legs
    glColor3f(0.0, 1.0, 0.0)
    mp_circle(x - 5, y, 4)  # Left leg outline (moved slightly outward, reduced radius)
    for radius in range(0, 4):
        mp_circle(x - 5, y, radius)  # Filled left leg

    mp_circle(x + 5, y, 4)  # Right leg outline (moved slightly outward, reduced radius)
    for radius in range(0, 4):
        mp_circle(x + 5, y, radius)  # Filled right leg
    # Eye
    glColor3f(1.0, 1.0, 1.0)  # White for the outer eye
    mp_circle(x + 12, y + 30, 2)  # Outer eye outline
    for radius in range(0, 2):
        mp_circle(x + 12, y + 30, radius)  # Filled outer eye

    glColor3f(0.0, 0.0, 0.0)  # Black for the pupil
    mp_circle(x + 12, y + 30, 1)  # Pupil
    for radius in range(0, 1):
        mp_circle(x + 12, y + 30, radius)  # Filled pupil


def draw_enemy_dino(x, y):
    glColor3f(1.0, 0.0, 0.0)  # Red color for the entire dinosaur

    # Body
    glColor3f(1.0, 1.0, 0.0)
    mp_circle(x, y + 15, 10)  # Body outline (reduced radius)
    for radius in range(0, 10):
        mp_circle(x, y + 15, radius)  # Filled body

    # Head
    glColor3f(1.0, 0.0, 0.0)
    mp_circle(x - 10, y + 30, 5)  # Head outline (mirrored left, reduced radius)
    for radius in range(0, 5):
        mp_circle(x - 10, y + 30, radius)  # Filled head

    # Pupil
    glColor3f(0.5, 0.2, 0.0)  # Black for the pupil
    mp_circle(x - 12, y + 30, 1)  # Pupil (mirrored left, unchanged size)
    for radius in range(0, 1):
        mp_circle(x - 12, y + 30, radius)  # Filled pupil

    # Neck
    glColor3f(1.0, 0.4, 0.7)  # Red color for neck
    mp_circle(x - 6, y + 22, 3)  # Neck outline (mirrored left, reduced radius)
    for radius in range(0, 3):
        mp_circle(x - 6, y + 22, radius)  # Filled neck

    # Legs
    glColor3f(1.0, 0.0, 0.0)  # Red color for legs
    mp_circle(x - 5, y, 4)  # Left leg outline (mirrored left, reduced radius)
    for radius in range(0, 4):
        mp_circle(x - 5, y, radius)  # Filled left leg

    mp_circle(x + 5, y, 4)  # Right leg outline (mirrored left, reduced radius)
    for radius in range(0, 4):
        mp_circle(x + 5, y, radius)  # Filled right leg


def draw_life_bar(x, y, health):
    bar_width = 100
    bar_height = 10
    health_width = (health / 100) * bar_width

    # Draw border
    glColor3f(1.0, 1.0, 1.0)
    mp_line(x, y, x + bar_width, y)
    mp_line(x + bar_width, y, x + bar_width, y + bar_height)
    mp_line(x + bar_width, y + bar_height, x, y + bar_height)
    mp_line(x, y + bar_height, x, y)

    # Draw health
    glColor3f(0.0, 1.0, 0.0)
    glBegin(GL_POINTS)
    for i in range(int(health_width)):
        for j in range(bar_height):
            glVertex2f(x + i, y + j)
    glEnd()


def draw_tree(x, y):
    tree_trunk_width = 6
    new_trunk_height = 20
    tree_circle_radius = 10

    # Trunk
    glColor3f(0.5, 0.3, 0.1)  # Brown trunk
    for i in range(tree_trunk_width):
        mp_line(x + i, y, x + i, y + new_trunk_height)

    # Foliage
    glColor3f(0.0, 1.0, 0.0)  # Green foliage
    mp_circle(x + tree_trunk_width // 2, y + new_trunk_height + tree_circle_radius, tree_circle_radius)
    for radius in range(0, tree_circle_radius):
        mp_circle(x + tree_trunk_width // 2, y + new_trunk_height + tree_circle_radius, radius)


def draw_food(x, y):
    glColor3f(1.0, 1.0, 0.0)  # Yellow food
    mp_circle(x, y, food_radius)


def draw_rain():
    glColor3f(0.9, 0.5, 0.0)  # Light blue color for raindrops
    glBegin(GL_POINTS)
    for drop in raindrops:
        glVertex2f(drop[0], drop[1])
    glEnd()


def spawn_raindrops():
    if len(raindrops) < max_raindrops:
        for _ in range(rain_spawn_rate):
            x = random.randint(0, WIDTH)  # Random x position
            y = HEIGHT  # Start at the top of the screen
            raindrops.append([x, y])


def up_raindrops():
    global raindrops
    new_raindrops = []
    for drop in raindrops:
        drop[1] -= rain_speed  # Move down
        if drop[1] > 0:  # Keep if still on screen
            new_raindrops.append(drop)
    raindrops = new_raindrops


def text_display(x, y, text, color=(1.0, 1.0, 1.0)):
    glColor3f(*color)
    glRasterPos2f(x, y)
    for char in text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(char))


def display():
    global game_over, score, day_theme, fight_mode, dino_health, enemy_health, extra_life, paused

    if paused:
        glClearColor(0.0, 0.0, 0.0, 1.0)
        glClear(GL_COLOR_BUFFER_BIT)
        text_display(WIDTH // 2 - 50, HEIGHT // 2, "Paused", color=(1.0, 1.0, 1.0))
        text_display(WIDTH // 2 - 120, HEIGHT // 2 - 30, "Press P to Resume", color=(1.0, 1.0, 1.0))
        glutSwapBuffers()
        return
    if game_over:
        # Clear the screen and display Game Over text
        glClearColor(0.0, 0.0, 0.0, 1.0)
        glClear(GL_COLOR_BUFFER_BIT)
        text_display(WIDTH // 2 - 80, HEIGHT // 2, "Game Over!", color=(1.0, 0.0, 0.0))
        text_display(WIDTH // 2 - 120, HEIGHT // 2 - 30, f"Score: {score}", color=(1.0, 1.0, 0.0))
        text_display(WIDTH // 2 - 120, HEIGHT // 2 - 60, "Press R to Restart", color=(1.0, 1.0, 1.0))
        glutSwapBuffers()
        return
    if day_theme:
        glClearColor(1.0, 0.8, 0.6, 1.0)  # soft orange for day
    else:
        glClearColor(0.0, 0.0, 0.0, 1.0)  # Black for night

    glClear(GL_COLOR_BUFFER_BIT)
    glLoadIdentity()
    glOrtho(0, WIDTH, 0, HEIGHT, -1, 1)

    if not fight_mode:
        if not game_over:
            draw_rain()
            draw_dino(dino_xx, current_y)
            for tree in trees:
                draw_tree(tree[0], tree[1])
            if food:
                draw_food(food[0], food[1])
            text_display(10, HEIGHT - 20, f"Score: {score}", color=(0.0, 0.0, 0.0) if day_theme else (1.0, 1.0, 1.0))
        else:
            text_display(WIDTH // 2 - 80, HEIGHT // 2, "Game Over!", color=(1.0, 0.0, 0.0))
            text_display(WIDTH // 2 - 120, HEIGHT // 2 - 30, f"Score: {score}", color=(1.0, 1.0, 0.0))
            text_display(WIDTH // 2 - 120, HEIGHT // 2 - 60, "Press R to Restart", color=(1.0, 1.0, 1.0))
    else:
        draw_dino(dino_xx, current_y)
        draw_enemy_dino(WIDTH - dino_xx, enemy_current_y)

        draw_life_bar(10, HEIGHT - 30, dino_health)
        draw_life_bar(WIDTH - 110, HEIGHT - 30, enemy_health)

        glColor3f(1.0, 1.0, 0.0)
        glBegin(GL_POINTS)
        for proj in projectiles:
            glVertex2f(proj[0], proj[1])
        for proj in enemy_projectiles:
            glVertex2f(proj[0], proj[1])
        glEnd()
    if food:
        draw_food(food[0], food[1])
    glutSwapBuffers()


def update_game_info():
    global game_over, score, current_y, jumping, falling, fight_mode, dino_health, enemy_health
    global trees, tree_spawn_timer, food, boost_jump, jump_height, tree_speed, bonus_jump, used_chance, extra_life
    global food, food_timer, food_radius, food_speed, projectiles, enemy_projectiles, enemy_jumping, enemy_falling, enemy_current_y, enemy_firing_timer, extra_life_used
    food_timer += 1
    if not food and food_timer > 300:
        food_y_min = base_y + 20  # Just above ground level
        food_y_max = base_y + boost_jump_height - 10  # Below the maximum jump height
        food = [WIDTH, random.randint(food_y_min, food_y_max)]  # Random y position in range
        food_timer = 0

    # Move food
    if food:
        food[0] -= food_speed
        if food[0] < 0:  # Remove off-screen food
            food = None

    # Check for collision with food ball
    if food:
        distance = math.sqrt((dino_xx - food[0]) ** 2 + (current_y - food[1]) ** 2)
        if distance < food_radius + 10:  # Check collision radius
            food = None
            tree_speed += 2
            score += 10
            boost_jump = True  # Enable boosted jump
            jump_height = boost_jump_height  # Set higher jump height
            jumping = True
            # Increase tree speed
    if jumping:
        current_y += jumping_speed
        if current_y >= base_y + jump_height:
            jumping = False
            falling = True
            if boost_jump:  # Reset to normal jump after boosted jump
                jump_height = norm_jump_height
                boost_jump = False
    elif falling:
        current_y -= jumping_speed
        if current_y <= base_y:
            falling = False
            current_y = base_y
    if fight_mode:
        # Player's dinosaur jump/fall logic
        if jumping:
            current_y += jumping_speed
            if current_y >= base_y + jump_height:
                jumping = False
                falling = True
        elif falling:
            current_y -= jumping_speed
            if current_y <= base_y:
                falling = False
                current_y = base_y

        # Enemy's dinosaur jump/fall logic
        if enemy_jumping:
            enemy_current_y += enemy_jumping_speed
            if enemy_current_y >= base_y + norm_jump_height:
                enemy_jumping = False
                enemy_falling = True
        elif enemy_falling:
            enemy_current_y -= enemy_jumping_speed
            if enemy_current_y <= base_y:
                enemy_falling = False
                enemy_jumping = True

        # Enemy fires projectiles with a cooldown
        enemy_firing_timer += 3
        if enemy_firing_timer > 100:  # Delay between shots
            enemy_projectiles.append([WIDTH - dino_xx - 15, enemy_current_y + 10])
            enemy_firing_timer = 0  # Reset firing cooldown

        # Handle player's projectile collisions with enemy
        new_projectiles = []
        for proj in projectiles:
            proj[0] += projectile_speed
            if proj[0] < WIDTH:
                new_projectiles.append(proj)
                # Check if the enemy dinosaur is hit by the projectile
                if WIDTH - dino_xx - 15 < proj[0] < WIDTH - dino_xx + 15 and enemy_current_y < proj[
                    1] < enemy_current_y + 20:
                    enemy_health -= 10  # Decrease enemy's health on hit
        projectiles = new_projectiles

        # Handle enemy's projectile collisions with player dinosaur
        new_enemy_projectiles = []
        for proj in enemy_projectiles:
            proj[0] -= projectile_speed
            if proj[0] > 0:
                new_enemy_projectiles.append(proj)
                # Check if the player's dinosaur is hit by the enemy's projectile
                if dino_xx - 15 < proj[0] < dino_xx + 15 and current_y < proj[1] < current_y + 20:
                    dino_health -= 10  # Decrease player's health on hit
        enemy_projectiles = new_enemy_projectiles

        # Check if the enemy's health is depleted
        if enemy_health <= 0:
            fight_mode = False  # End the fight mode
            score += 50  # Give score bonus after enemy is defeated
            if not extra_life:
                extra_life = True  # Give the player an extra life
                reset_game()  # Reset the game after enemy defeat
            else:
                game_over = True  # Game over after extra life is used

        # Check if the player's health is depleted
        if dino_health < 0:
            game_over = True
            return  # Set game over if the player's health reaches zero

    elif not game_over:
        # Regular game play continues as before
        tree_spawn_timer += 1
        if tree_spawn_timer > 100:
            trees.append([WIDTH, base_y])
            tree_spawn_timer = 0

        new_trees = []
        for tree in trees:
            tree[0] -= tree_speed
            if tree[0] + tree_below_width > 0:
                new_trees.append(tree)
            else:
                score += 1
        trees[:] = new_trees

        # Handle tree collision with the dinosaur (for triggering fight mode)
        for tree in trees:
            tree_center_x = tree[0] + tree_below_width // 2
            tree_center_y = tree[1] + new_trunk_height + tree_leaf_radius

            if (dino_xx + 10 > tree[0] and dino_xx - 10 < tree[0] + tree_below_width) and \
                    (current_y < tree[1] + new_trunk_height):
                if extra_life:
                    if not extra_life_used:
                        extra_life_used = True
                        reset_game()  # Reset game after extra life used
                    else:
                        game_over = True  # Game over after extra life is used
                else:
                    fight_mode = True  # Trigger the fight mode
                    jumping = True
                    enemy_jumping = True
                break

        # Handle jumping/falling behavior in normal game mode (not in fight mode)
        if jumping:
            current_y += jumping_speed
            if current_y >= base_y + jump_height:
                jumping = False
                falling = True
        elif falling:
            current_y -= jumping_speed
            if current_y <= base_y:
                falling = False
                current_y = base_y

        spawn_raindrops()
        up_raindrops()


# Now, if the player's health goes to zero (dino_health <= 0), the game will end and game_over will be set to True.


# Added global firing timer for enemy
enemy_firing_timer = 0


def reset_game():
    global trees, food, jumping, falling, boost_jump, jump_height, projectiles, enemy_projectiles
    global dino_health, enemy_health, used_chance, extra_life, enemy_current_y, enemy_jumping, enemy_falling

    trees = []
    food = None
    jumping = False
    falling = False
    boost_jump = False
    jump_height = norm_jump_height
    projectiles = []
    enemy_projectiles = []
    dino_health = 100
    enemy_health = 100
    used_chance = False
    enemy_current_y = base_y
    enemy_jumping = False
    enemy_falling = False


paused = False


def restart_game():
    global game_over, score, dino_health, enemy_health, fight_mode, trees, food, jumping, falling, paused, day_theme

    # Reset game state
    game_over = False
    score = 0
    dino_health = 100
    enemy_health = 100
    fight_mode = False
    trees = []
    food = None
    jumping = False
    falling = False
    paused = False
    day_theme = False
    reset_game()  # Reset additional game-related variables


def handle_keys(key, x, y):
    global jumping, falling, game_over, day_theme, projectiles, fight_mode, paused

    if key == b'\x1b':  # Escape to quit
        glutLeaveMainLoop()

    if key == b' ' and not jumping and not falling and not paused:  # Space to jump
        jumping = True

    if key == b'r' and game_over:  # R to restart the game
        restart_game()

    if key == b't':  # Toggle day/night theme
        day_theme = not day_theme

    if key == b'f' and fight_mode and not paused:  # Fire projectile in fight mode
        projectiles.append([dino_xx + 15, current_y + 10])

    if key == b'p':  # Pause/resume the game
        paused = not paused


# Add keyboard function to OpenGL's GLUT main loop


def timer(value):
    update_game_info()
    glutPostRedisplay()
    glutTimerFunc(1000 // 60, timer, 0)


def main():
    glutInit()
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB)
    glutInitWindowSize(WIDTH, HEIGHT)
    glutCreateWindow(b"OpenGL Game")

    glClearColor(0.0, 0.0, 0.0, 1.0)

    glutDisplayFunc(display)
    glutKeyboardFunc(handle_keys)
    glutTimerFunc(1000 // 60, timer, 0)

    glutMainLoop()


if __name__ == "__main__":
    main()